/*
 * The MIT License (MIT)
 * Copyright (c) 2016 Maksym Borodin <borodin.maksym@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

package xenserver

import (
	"bytes"
	"fmt"
	"log"
	"sort"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/helper/hashcode"
	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
	xenapi "github.com/terra-farm/go-xen-api-client"
)

const (
	vifSchemaNetworkUUID = "network_uuid"
	vifSchemaMac         = "mac"
	vifSchemaMtu         = "mtu"
	vifSchemaDevice      = "device"
	vifSchemaOtherConfig = "other_config"
)

func readVIFsFromSchema(c *Connection, s []interface{}) ([]*VIFDescriptor, error) {
	vifs := make([]*VIFDescriptor, 0, len(s))

	for _, schm := range s {
		data := schm.(map[string]interface{})

		network := &NetworkDescriptor{}
		if id, ok := data[vifSchemaNetworkUUID]; ok {
			network.UUID = id.(string)
		}
		if err := network.Load(c); err != nil {
			return nil, err
		}
		mtu := data[vifSchemaMtu].(int)
		device := data[vifSchemaDevice].(int)
		var mac string = data[vifSchemaMac].(string)
		mac_autogenerated := true
		if mac != "" {
			mac_autogenerated = false
		}

		var other_config = make(map[string]string)

		for k, v := range data[vifSchemaOtherConfig].(map[string]interface{}) {
			other_config[k] = v.(string)
		}

		vif := &VIFDescriptor{
			Network:            network,
			MAC:                mac,
			IsAutogeneratedMAC: mac_autogenerated,
			DeviceOrder:        device,
			MTU:                mtu,
			OtherConfig:        other_config,
		}

		vifs = append(vifs, vif)
	}

	return vifs, nil
}

func fillVIFSchema(vif VIFDescriptor) map[string]interface{} {
	log.Println("[DEBUG] VIF MAC ", vif.MAC)
	mac := ""
	if !vif.IsAutogeneratedMAC {
		mac = vif.MAC
	}
	return map[string]interface{}{
		vifSchemaNetworkUUID: vif.Network.UUID,
		vifSchemaMac:         mac,
		vifSchemaMtu:         vif.MTU,
		vifSchemaDevice:      vif.DeviceOrder,
		vifSchemaOtherConfig: vif.OtherConfig,
	}
}

func createVIF(c *Connection, vif *VIFDescriptor) (*VIFDescriptor, error) {
	log.Println(fmt.Sprintf("[DEBUG] Creating VIF for VM %q in network %q", vif.VM.Name, vif.Network.Name))

	if vif.DeviceOrder == 0 {
		vif.DeviceOrder = vif.VM.VIFCount
	}

	vifObject := xenapi.VIFRecord{
		VM:               vif.VM.VMRef,
		Network:          vif.Network.NetworkRef,
		MTU:              vif.MTU,
		MACAutogenerated: vif.IsAutogeneratedMAC,
		MAC:              vif.MAC,
		Device:           strconv.Itoa(vif.DeviceOrder),
		OtherConfig:      vif.OtherConfig,
		LockingMode:      xenapi.VifLockingModeNetworkDefault,
	}

	vifRef, err := c.client.VIF.Create(c.session, vifObject)
	if err != nil {
		return nil, err
	}

	log.Println(fmt.Sprintf("[DEBUG] Created VIF"))

	vif.VIFRef = vifRef
	err = vif.Query(c)
	if err != nil {
		return nil, err
	}

	log.Println(fmt.Sprintf("[DEBUG] VIF  UUID %q", vif.UUID))

	if vif.VM.PowerState == xenapi.VMPowerStateRunning {
		err = c.client.VIF.Plug(c.session, vif.VIFRef)
		if err != nil {
			return nil, err
		}

		log.Println(fmt.Sprintf("[DEBUG] Plugged VIF %q to VM %q", vif.UUID, vif.VM.Name))
	}

	return vif, nil
}

func vifHash(v interface{}) int {
	var buf bytes.Buffer
	m := v.(map[string]interface{})
	var count int = 0
	b, _ := buf.WriteString(fmt.Sprintf("%s-", m["network_uuid"].(string)))
	b, _ = buf.WriteString(fmt.Sprintf("%d-", m["mtu"].(int)))
	b, _ = buf.WriteString(fmt.Sprintf("%d-", m["device"].(int)))
	b, _ = buf.WriteString(fmt.Sprintf("%s-",
		strings.ToLower(m["mac"].(string))))

	if _otherConfig, ok := m[vifSchemaOtherConfig]; ok {
		var otherConfig = make(map[string]string)

		for k, v := range _otherConfig.(map[string]interface{}) {
			otherConfig[k] = v.(string)
		}

		// Sort keys to guarantee order
		var keys []string
		for k, _ := range otherConfig {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		b, _ = buf.WriteRune('>')
		for _, k := range keys {
			b, _ = buf.WriteString(k)
			b, _ = buf.WriteString(":")
			b, _ = buf.WriteString(otherConfig[k])
			b, _ = buf.WriteString(";")
		}
		b, _ = buf.WriteRune('<')
	}

	count += b
	log.Println("Consumed total ", count, " bytes to generate hash")

	return hashcode.String(buf.String())
}

func resourceVIF() *schema.Resource {
	return &schema.Resource{

		Schema: map[string]*schema.Schema{
			vifSchemaNetworkUUID: &schema.Schema{
				Type:     schema.TypeString,
				Optional: true,
			},
			vifSchemaMac: &schema.Schema{
				Type:     schema.TypeString,
				Optional: true,
			},
			vifSchemaMtu: &schema.Schema{
				Type:     schema.TypeInt,
				Optional: true,
			},
			vifSchemaDevice: &schema.Schema{
				Type:     schema.TypeInt,
				Optional: true,
				Computed: true,
			},
			vifSchemaOtherConfig: &schema.Schema{
				Type:     schema.TypeMap,
				Optional: true,
			},
		},
	}
}
